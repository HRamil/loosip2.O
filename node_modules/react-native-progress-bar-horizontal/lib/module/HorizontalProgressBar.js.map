{"version":3,"sources":["HorizontalProgressBar.tsx"],"names":["React","useState","useEffect","useRef","useCallback","View","Animated","Easing","styles","HorizontalProgressBar","progress","animated","fillColor","unfilledColor","borderWidth","borderColor","borderRadius","width","height","duration","translateXValue","Value","current","containerWidth","setContainerWidth","layoutHadler","event","nativeEvent","layoutWidth","layout","setValue","Math","abs","progressValue","timing","toValue","easing","cubic","isInteraction","useNativeDriver","start","container","backgroundColor","transform","translateX"],"mappings":"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","sourcesContent":["import React, {\n  FunctionComponent,\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n} from 'react';\nimport { View, LayoutChangeEvent, Animated, Easing } from 'react-native';\n\nimport { styles } from './styles';\nimport type { HorizontalProgressBarProps } from './types';\n\nconst HorizontalProgressBar: FunctionComponent<HorizontalProgressBarProps> = ({\n  progress = 0,\n  animated = true,\n  fillColor = '#000000',\n  unfilledColor = '',\n  borderWidth = 1,\n  borderColor = '#000000',\n  borderRadius = 4,\n  width = null,\n  height = 6,\n  duration = 500,\n}) => {\n  // Animate transform style prop so native driver can be used\n  const translateXValue = useRef(new Animated.Value(0)).current;\n  const [containerWidth, setContainerWidth] = useState(0);\n\n  const layoutHadler = useCallback(\n    (event: LayoutChangeEvent) => {\n      if (width === null) {\n        const { nativeEvent } = event;\n        const layoutWidth = nativeEvent.layout.width;\n\n        translateXValue.setValue(-Math.abs(layoutWidth));\n        setContainerWidth(layoutWidth);\n      }\n    },\n    [translateXValue, width]\n  );\n\n  useEffect(() => {\n    if (width !== null) {\n      translateXValue.setValue(-Math.abs(width));\n      setContainerWidth(width);\n    }\n  }, [translateXValue, width]);\n\n  useEffect(() => {\n    let progressValue = progress;\n\n    if (progressValue > 1) {\n      progressValue = 1;\n    } else if (progressValue < 0) {\n      progressValue = 0;\n    }\n\n    if (!animated) {\n      translateXValue.setValue(\n        -Math.abs(containerWidth * progressValue - containerWidth)\n      );\n      return;\n    }\n\n    Animated.timing(translateXValue, {\n      toValue: -Math.abs(containerWidth * progressValue - containerWidth),\n      duration,\n      easing: Easing.cubic,\n      isInteraction: true,\n      useNativeDriver: true,\n    }).start();\n  }, [translateXValue, containerWidth, progress, animated, duration]);\n\n  return (\n    <View\n      style={{\n        ...styles.container,\n        ...(unfilledColor ? { backgroundColor: unfilledColor } : {}),\n        ...(width ? { width } : {}),\n        height,\n        borderWidth,\n        borderColor,\n        borderRadius,\n      }}\n      onLayout={layoutHadler}\n    >\n      {containerWidth !== 0 && (\n        <Animated.View\n          style={{\n            ...styles.progress,\n            backgroundColor: fillColor,\n            borderRadius,\n            transform: [{ translateX: translateXValue }],\n          }}\n        />\n      )}\n    </View>\n  );\n};\n\nexport default HorizontalProgressBar;\n"]}